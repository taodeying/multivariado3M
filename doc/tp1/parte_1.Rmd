---
title: "Trabajo practico 1"
subtitle: "Parte 1"
author: "Grupo ....."
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## Librerias

```{r}
library(FactoMineR)
library(kableExtra)
library(tidyverse)
```

## Datos

```{r}
datos <- read_csv2(here::here("data", "raw", "DAMASCO.csv"))
```

Inspeccionamos con `glimpse(datos)`

```{r}
glimpse(datos)
```

**A.** Cuáles son los valores de $n$ y $p$? Cuanto vale y que indica el valor 
$x_{32}$ ? Y el vector $x_6$ ?

El valor de $n$ es `r nrow(datos)` y el valor de $p$ es `r ncol(datos)`. El
valor de $x_{32}$ es `r datos[[3, 2]]` e indica el tamaño de la flor de la 
observacion 3. El vector $x_6$ indica la relacion entre el ancho y largo de la 
hoja.

**B.** Cómo clasificaría las variables sobre las que se está trabajando ?

Las variables con las que se esta trabajando son de tipo continuo en todos los 
casos. Mas aun, todas estan medidas en escala de intervalo.

**C.** Encuentre el vector de medias y matriz de varianzas-covariancias 
asociados a la tabla de datos.

Las medias son:

```{r}
datos %>% 
    select(-VAR) %>% 
    summarise_all(mean) %>% 
    round(1) %>% 
    kable() %>% 
    kable_styling(font_size = 12) %>% 
    kable_classic_2()
```

La matriz de covarianza es:

```{r, out.width=.5}
datos %>% 
    select(-VAR) %>%  
    cov() %>%  
    round(1) %>% 
    kable() %>% 
    kable_styling(font_size = 12) %>% 
    kable_classic_2() 
```

**D.** Podría decir cuál y cuáles variables son las más dispersas ?

Utilizando el coeficiente de variación, podemos decir que las variables más 
dispersas, en orden decreciente, son:

```{r}

datos %>% select(-VAR) %>%
    summarise_all(function(x) sd(x) / mean(x)) %>% 
    pivot_longer(cols = everything(), names_to = "VAR", values_to = "CV") %>% 
    arrange(desc(CV)) %>% 
    mutate(CV = round(CV, 1)) %>%
    kable() %>% 
    kable_styling(font_size = 12) %>% 
    kable_classic_2()
```

**E.** Estandarice las variables por media y desvío. Ahora puede responder al 
inciso (d) ?

```{r}
# No utilizamos la primer columna
datos_std = scale(datos[-1])
```

Como son variables estandarizadas, el coeficiente de variacion no existe,
pero todas tienen desvio estandar 1 (ya que la media es 0)

```{r}
datos_std %>%
    as_tibble() %>% 
    summarise_all(function(x) sd(x, na.rm=TRUE) /  mean(x, na.rm=TRUE)) %>% 
    round(1)
```

**F.** Halle la matriz de correlación. Que variables son las más relacionadas?

La matriz de correlación es:

```{r}
datos %>% 
    select(-VAR) %>%
    cor() %>% 
    round(1)  %>% 
    kable() %>% 
    kable_styling(font_size = 12)%>% 
    kable_classic_2()
```

A continuación una representacion grafica de la matriz de correlacion:      

```{r}
datos%>%
    select(-VAR) %>%
    cor() %>%
    corrplot::corrplot(
      method = "circle", 
      type = "lower", 
      tl.srt = 15
    )
```

**G.** Pueden dividirse las variables en subgrupos, de modo que las variables 
dentro de un mismo subgrupo tengan elevadas correlaciones entre sí y que las que
se encuentren en subgrupos diferentes tengan bajas correlaciones? Si es así, 
cuáles variables quedan en cada uno de los subgrupos?

* Los subgrupos de variables con altas correlaciones son los siguientes: 

1. Peso, longitud, ancho y espesor del fruto (caracteristicas del fruto)
1. Peso, longitud y ancho del endocarpio (caracteristicas del endocarpio)
1. Tamaño de la flor, longitu y ancho del petalo (caracteristicas de la flor)

* El subgrupo de variables con bajas correlaciones son los siguientes: 

1. Superficie de la hoja, relacion entre peciolo-limbo y relacion entre longitud
y ancho de la hoja (caracteristicas de la hoja); tamaño de la flor, longitud y 
ancho del petalo (caracteristicas de la flor)

Cabe destacar que la superficie de la hoja y relacion peciolo-limbo estan muy 
poco correlacionadas con el resto de las variables.

**H.** Encuentre la matriz que mide el grado de similaridad entre las variedades
en función de la distancia euclídea calculada sobre los datos originales.


```{r}
dist = datos %>% 
    select(-VAR) %>% 
    data.frame()

rownames(dist) <- datos$VAR

dist %>% 
    dist(method = "euclidean", diag = TRUE, upper = TRUE) %>% 
    as.matrix() %>% 
    round(1) %>% 
    kable() %>% 
    kable_styling(font_size = 8) %>% 
    kable_classic_2()

```

**I.** Podría decir cuales son los tres pares de variedades que presentan mayor 
semejanza?

Los pares de variaedades que presentan mayor semejanza son:

 1. CORBATO y PALAU, con una distancia de 4.8
 1. GINESTA y MANRI, con una distancia de 5.7
 1. GANDIA y MANRI, con una distancia de 5.8

**J.** Repita lo realizado en el inciso (h) pero sobre las variables 
estandarizadas por media y desvío estándar. Son las mimas las tres variedades 
más parecidas? Comente al respecto

```{r}
dist_std <- datos %>% 
    select(-VAR) %>% 
    scale() %>%
    data.frame()

rownames(dist_std) <- datos$VAR

dist_std %>% 
    dist(method = "euclidean", diag = TRUE, upper = TRUE) %>% 
    as.matrix() %>% 
    round(1) %>% 
    kable() %>% 
    kable_styling(font_size = 8) %>% 
    kable_classic_2()
```

Con los datos estandarizados, los pares de variedades mas parecidas son:
  
1. CURROT y CURROT.T, con una distancia de 1.4
1. R.CARLET y CORBATO, con una distancia de 1.5
1. PALABRAS y GINESTA, con una distancia de 2.1

**K.** Mida el grado de concordancia entre ambas matrices de distancia.

```{r}


dist_ <- dist %>% 
    dist(method = "euclidean", diag = TRUE, upper = TRUE) 

dist_std_ <- dist_std %>% 
    dist(method = "euclidean", diag = TRUE, upper = TRUE)


conc <- cor(dist_, dist_std_) %>%
      as_tibble() %>%
      round(2) %>%
      rename(CONCORDANCIA = value)
```

El grado de concordancia entre las matrices de distancias es: `r conc `.

A continuacion se realiza una representacion grafica:

```{r}

plot(
  dist_, 
  dist_std_, 
  ylab = "Distancias euclideas estandarizadas", 
  xlab = "Distancis euclideas", 
  main = "Concordancia entre las matrices de distancias euclideas"
)
```

**L.** Realice un Análisis de Componentes Principales utilizando de la matriz de
correlaciones.

Los autovalores obtenidos son los siguientes:

```{r}
datos_std <- data.frame(datos_std)
rownames(datos_std) <- datos$VAR

pca <- PCA(datos_std, ncp = 2, graph = FALSE)

pca$eig %>%
  data.frame() %>%
  rename(
    "Autovalores" = "eigenvalue", 
    "% varianza" = "percentage.of.variance", 
    "% varianza acumulada" = "cumulative.percentage.of.variance" 
  ) %>%
  kable() %>%
  kable_classic_2()
```

Tambien pueden observarse graficamente: 

```{r}
barplot(pca$eig[, 1], main = "AUTOVALORES", names.arg = 1:nrow(pca$eig))
```

Y los autovectores (cargas asociadas a cada componente) son: 

```{r}
pca$var$coord %>%
  kable() %>%
  kable_classic_2()
```


**M.** Analice los porcentaje de variabilidad explicada por los primeros ejes 
principales.

Observando los autovalores y el porcentaje de varianza explicada de cada uno, 
podemos decir que la primer componente explica el `r round(pca$eig[1, 2], 2)`%, 
mientras que la segunda componente explica `r round(pca$eig[2, 2], 2)`%. Luego, 
la varianza total explicada por estas dos componentes es 
`r round(pca$eig[2, 3], 2)`%.

**N.** Establezca intuitivamente grupos de variedades similares según su 
cercanía en el plano principal.

A continuacion se presenta la representacion grafica de las variedades en el 
plano principal:

```{r}
pc1 <- pca$ind$coord[, 1]
pc2 <- pca$ind$coord[, 2]
etiquetas <- rownames(pca$ind$coord)

plot(
  pc1,
  pc2, 
  ylab = "2° COMPONENTE PRINCIPAL", 
  xlab = "1° COMPONENTE PRINCIPAL", 
  xlim = c(-6,6), 
  ylim = c(-3,3)
)
abline(h = 0, lty = 3)
abline(v = 0, lty = 3)
text(pc1, pc2, etiquetas, pos = 3)
```

Tras observar el grafico podemos decir que las variedades mas similares son 
MARTINET, CANINO.T y BLANCO. Otro grupo podria estar conformado por CANINO y 
TADEO. La variedad GABACHET no tiene semejanza con ninguna de las otras 
variedades.

**O.** Encuentre e interprete gradientes de las variables originales en el plano
principal en función de sus cargas sobre las dos primeras componentes.

```{r}
pc1_ <- pca$var$coord[, 1]
pc2_ <- pca$var$coord[, 2]
etiquetas <- rownames(pca$var$coord)

plot(
  pc1_,
  pc2_, 
  ylab = "2° COMPONENTE PRINCIPAL", 
  xlab = "1° COMPONENTE PRINCIPAL", 
  xlim = c(-6,6), 
  ylim = c(-3,3)
)
abline(h = 0, lty = 3)
abline(v = 0, lty = 3)
text(pc1, pc2, etiquetas, pos = 3)
```

**P.** Caracterice los grupos determinados en el inciso (N) según los gradientes
descriptos en (O).

**R.** Con el software `R` realice el ACP recurriendo a operaciones con 
matrices (decomposición espectral)

Realizando la descomposicion espectral, los autovalores son los siguientes:

```{r}
x <- as.matrix(datos_std)
cor <- cor(x)
autovalores_ <- eigen(cor)

round(autovalores_$values, 1) %>%
  kable(col.names = "AUTOVALORES") %>%
  kable_styling(full_width = FALSE) %>%
  kable_classic_2() 
```

Y los autovectores:

```{r}
round(autovalores_$vectors[, 1:2], 1) %>%
  kable(col.names = c("AUTOVECTOR 1", "AUTOVECTOR 2")) %>%
  kable_styling(full_width = FALSE) %>%
  kable_classic_2()
```

Las nuevas coordenadas de las variaedades sobre las componentes halladas:

```{r}
p <- as.matrix(autovalores_$vectors)
y <- x %*% p
colnames(y) <- etiquetas
rownames(y) <- datos$VAR

round(y, 1) %>%
  kable() %>%
  kable_classic_2()
```

**S.**  Verifique que con el enfoque Biplot (DVS) llega a los mismos resultados

Valores singulares (d):

```{r}
dvs <- svd(x)

round(dvs$d, 1) %>%
  kable(col.names = "d")%>%
  kable_classic_2()
```


Vectores singulares por izquierda (u):

```{r}
colnames(dvs$u) <- etiquetas

dvs$u %>%
  round(1) %>%
  kable() %>%
  kable_classic_2()
```

Vectores singulares por derecha (v):

```{r}
colnames(dvs$v) <- etiquetas

dvs$v %>%
  round(1) %>%
  kable() %>%
  kable_classic_2()
```


Las nuevas cordenadas de las variedades halladas a traves de DVS:

```{r}
u <- dvs$u
v <- dvs$v
d <- diag(dvs$d, 13, 13)
ydvs <- u %*% d
colnames(ydvs) <- etiquetas
rownames(ydvs) <- datos$VAR
  
round(ydvs, 1) %>%
  kable() %>%
  kable_classic_2()
```


**FALTA VERIFICAR QUE SE LLEGA AL MISMO RESULTADO**