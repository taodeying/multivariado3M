---
title: "Trabajo practico 1"
subtitle: "Ejercicio 2"
author: "Grupo ....."
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
    html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, message = FALSE, warning = FALSE, fig.align = "center"
)
```

## Librerias

```{r}
library(cluster)
library(ggrepel)
library(ggdendro)
library(kableExtra)
library(tidyverse)
```

## Datos

```{r}
datos <- read_csv2(here::here("data", "raw", "CUALITATIVAS.csv"))
```

```{r}
glimpse(datos)
```

Vemos que todas las variables fueron importadas como de tipo `"character"`, lo
que es correcto en este caso, ya que todas representan variables cualitativas. 
Ahora pasamos a ver que variables tienen datos desconocidos (marcados con "-1").
Los reemplazaremos por valores `NA`.

```{r, cap}
sapply(datos, function(x) paste(round(mean(x == "-1") * 100, 2), "%")) %>%
  t() %>%
  as.data.frame() %>%
  kable(caption = "Tabla 1: Porcentaje de datos perdidos por variable") %>%
  kable_styling(font_size = 12, full_width = FALSE) %>% 
  kable_classic_2() 
```

Por lo que vemos que en las variables `CLADOSP` y `CMV` se tiene un 32% y un 27%
de valores perdidos respectivamente. Procedemos a identificarlos como `NA`.

```{r}
datos <- datos %>%
  mutate(
    CLADOSP = ifelse(CLADOSP == "-1", NA, CLADOSP),
    CMV = ifelse(CMV == "-1", NA, CMV)
  )
```

**A.** Cuantifique (en forma manual) la similaridad entre las variedades 
correspondientes a la primera y segunda fila en función del porcentaje de 
caracteres comunes respecto al número de caracteres totales. Idem las variedades
asociadas a las filas 12 y 13 (incluir la variable TIPO)

Obtenemos dos vectores que representan a cada una de las dos primeras variedades
y luego calculamos el la proporcion de variables donde ambas variedades 
coinciden. 

```{r}
variedad1 <- datos[1, -1] %>% unlist() %>% unname()
variedad2 <- datos[2, -1] %>% unlist() %>% unname()
similaridad_1_2 <- mean(variedad1 == variedad2, na.rm = TRUE) * 100
```

La similaridad entre las variedades de la fila 1 y 2 es del
`r paste0(round(similaridad_1_2, 2), "%")`. Luego, de manera analoga para el 
par de variedades 12 y 13

```{r}
variedad12 <- datos[12, -1] %>% unlist() %>% unname()
variedad13 <- datos[13, -1] %>% unlist() %>% unname()
similaridad_12_13 <- mean(variedad12 == variedad13, na.rm = TRUE) * 100
```

La similaridad entre las variedades de la fila 12 y 13 es del
`r paste0(round(similaridad_12_13, 2), "%")`.

**B.** Halle una matriz de similaridad entre variedades en función del 
coeficiente SM generalizado.

<!-- Extensión Coeficiente Similaridad S.M. p.26 teoria -->

La funcion `daisy()` del paquete `cluster` requiere que las variables 
cualitativas sean de tipo `"factor"`. En nuestro caso, son de tipo 
`"character"`, por lo que necesitamos una nueva version de nuestros datos
donde las columnas son factores. 

```{r}
datos_fct <- datos %>%
  mutate_all(as.factor)
```

```{r}
matriz_distancia <- daisy(datos_fct[-1], "gower")
matriz_similaridad <- 1 - matriz_distancia
```

Comprobemos, por ejemplo, si las similaridad entre las unidades 1 y 2 computada
mediante `daisy()` es igual a la que computamos a mano.

```{r}
matriz_similaridad[1] == (similaridad_1_2 / 100)
```

Por lo que ambos resultados son iguales.

**C.** Aplique Análisis de Coordenadas principales para representar en un 
espacio bidimensional la semejanza entre las variedades.

```{r}
coordenadas_principales <- cmdscale(sqrt(matriz_distancia), eig = TRUE)
```

Vamos a hacer el grafico

```{r}
datos_CP <- as.data.frame(coordenadas_principales$points)
colnames(datos_CP) <- c("c1", "c2")
datos_CP$etiqueta <- datos$VARIEDAD
datos_CP$variedad <- substr(datos_CP$etiqueta, 1, 1)
```


```{r, fig.cap="Figura 1: Caracterizacion cualitativa de las variedades de pepino."}
ggplot(datos_CP) + 
  geom_point(aes(c1, c2, color = variedad), size = 4) + 
  geom_label_repel(aes(c1, c2, label = etiqueta), max.overlaps = 30) + 
  geom_vline(xintercept = 0, linetype = "dashed") + 
  geom_hline(yintercept = 0, linetype = "dashed") + 
  labs(
    x = "Coordenada 1",
    y = "Coordenada 2",
    color = "Tipo de fruto"
  )
```

En aquellos casos que mas de una etiqueta apunta hacia el mismo punto sucede que 
las variedades coinciden en terminos de las variables analizadas y en 
consecuencia los puntos que los representan estan encimados. Por ejemplo,
las variedades `A5`, `A6`, `A7`, `A8` tienen identicos valores para todas las 
variables.

```{r}
datos %>%
  filter(VARIEDAD %in% c("A5", "A6", "A7", "A8")) %>%
  kable() %>% 
  kable_styling(font_size = 12, full_width = FALSE) %>% 
  kable_classic_2() 
```

**D.** Conforme grupos de variedades según su homogeneidad en la caracterización
agronómica cualitativa.

En la Figura 1 se puede ver que las variedades de los tipos de fruto A y H se 
se agrupan de manera que respetan al tipo de fruto y se diferencian del resto. 
Tambien existe una agrupacion, ya no tan clara, para las variedades de los 
grupos F y P. En este caso, si no estuviera el color que diferencie a los tipos
de frutos, no podriamos diferenciar a estos dos grupos claramente. 
Por ejemplo, las variedades F2, F6 y P1 estan muy cercanas en el plano y las
podriamos haber tomado como parte de un mismo grupo.

Tambien podemos ver que la variabilidad de las variedades dentro de cada tipo de 
fruto difiere. Por ejemplo, para el tipo de fruto **H**, se tiene que casi todas
las variedades se corresponden con dos categorizaciones particulares (por eso 
vemos tantos puntos encimados). Por otro lado, todas las variedades del tipo de 
fruto **P** se corresponden con una configuracion unica de las variables cualitativas.

**E.** Encuentre el dendograma ultramétrico con ligamiento UPGMA correspondiente

```{r}
cualitativas_CP <- hclust(matriz_distancia, method = "average")
```

```{r}
# fuente: https://atrebas.github.io/post/2019-06-08-lightweight-dendrograms/
dendro_data_k <- function(hc, k) {
  
  hcdata <- ggdendro::dendro_data(hc, type = "rectangle")
  seg <- hcdata$segments
  labclust <- cutree(hc, k)[hc$order]
  segclust <- rep(0L, nrow(seg))
  heights <- sort(hc$height, decreasing = TRUE)
  height <- mean(c(heights[k], heights[k - 1L]), na.rm = TRUE)
  
  for (i in 1:k) {
    xi <- hcdata$labels$x[labclust == i]
    idx1 <- seg$x >= min(xi) & seg$x <= max(xi)
    idx2 <- seg$xend >= min(xi) & seg$xend <= max(xi)
    idx3 <- seg$yend < height
    idx <- idx1 & idx2 & idx3
    segclust[idx] <- i
  }
  
  idx <- which(segclust == 0L)
  segclust[idx] <- segclust[idx + 1L]
  hcdata$segments$clust <- segclust
  hcdata$segments$line <- as.integer(segclust < 1L)
  hcdata$labels$clust <- labclust
  hcdata
}

dendro_data <- dendro_data_k(cualitativas_CP, k=4)
```

```{r, fig.height=6.5, fig.width=6}
ggplot(dendro_data$segments) + 
  geom_segment(
    aes(x = x, y = y, xend = xend, yend = yend, color = as.factor(clust)),
    size = 1.2,
    lineend = "round"
  ) + 
  geom_text(
    aes(x = x, y = y - 0.025, label = label, color = as.factor(clust)), 
    data = dendro_data$labels
  ) + 
  coord_flip() + 
  labs(
    title = "Dendograma Ultrametrico con ligamiento UPGMA",
    y = "Distancia"
  ) + 
  scale_colour_manual(
    values = c("grey30", scales::hue_pal()(4))
  ) + 
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    panel.background = element_blank(),
    axis.title.x = element_text(size = 14), 
    axis.title.y = element_blank(), 
    axis.text.x = element_text(size = 12),
    axis.text.y = element_blank(), 
    axis.line = element_blank(), 
    axis.ticks.y = element_blank(),
    plot.title = element_text(hjust = 0.5),
    legend.position = "none"
  )
```

**F.** Mida a través de su matriz cofenética la concordancia con la matriz de 
distancias que le dio origen

```{r}
distancia_cofenetica_CP <- cophenetic(cualitativas_CP)
concordancia <- cor(distancia_cofenetica_CP, matriz_distancia)
```

```{r}
concordancia_df <- data.frame(
    x = as.vector(distancia_cofenetica_CP),
    y = as.vector(matriz_distancia)
)

ggplot(concordancia_df) + 
    geom_point(aes(x, y), size = 3, alpha = 0.5) + 
    labs(
        x = "Distancia cofenetica",
        y = "Distancia original"
    )
```

La concordancia entre la matriz de distancias cofenetica y la matriz de 
distancia original es igual  a `r round(concordancia, 3)`.

**G.** Cuantifique concordancia entre plano principal de ACoordP y Cluster

```{r}
concordancia <- cor(distancia_cofenetica_CP, dist(coordenadas_principales$points))
```

La concordancia concordancia entre plano principal de ACoordP y Cluster es 
`r round(concordancia, 3)`.