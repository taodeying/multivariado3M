---
title: "Trabajo practico 1"
subtitle: "Ejercicio 5"
author: "Grupo ....."
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  pdf_document:
    extra_dependencies: ["float"]
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, message = FALSE, warning = FALSE, fig.align = "center",
  fig.pos = "H", out.extra = "", fig.height = 4, fig.width = 6
)
```

```{r}
library(ape)
library(ggrepel)
library(kableExtra)
library(tidyverse)
source(here::here("src", "utils.R"))
```

```{r}
datos <- read_csv2(here::here("data", "raw", "RAPDS.csv"))
```

A) Halle la distancia genética de Prevosti entre variedades

    ```{r}
    datos_df <- data.frame(datos[-1])
    rownames(datos_df) <- datos$Var
    # Dist computa distancia entre filas, y las filas de datos son las variedades.
    # 33 es la cantidad de variables
    ```
    
    Para calcular esta distancia usamos la siguiente sentencia
    
    ```{r, echo=TRUE}
    matriz_distancia <- dist(datos_df, method = "manhattan", diag = TRUE) / 33
    ```
    
    ```{r}
    # Guardamos matriz de distancia para ser utilizada en otras partes
    saveRDS(
      matriz_distancia, 
      here::here("doc", "tp1", "shared", "parte_5", "matriz_distancia.rds")
    )
    ```
    
    
    Mostramos la matriz resultante de manera parcial, ya que es muy grande como
    para mostrarla de manera completa en una pagina.
    
    ```{r}
    matriz_distancia %>% 
        as.matrix() %>%
        round(2) %>% 
        `[`(1:10, 1:10) %>%
        kable() %>% 
        kable_styling(font_size = 12, latex_options = "HOLD_position") %>% 
        kable_classic_2() 
    ```

A) Podría aplicar el coeficiente de similaridad SM ? Porque ?

    Si, pero no lo hacemos porque perderiamos informacion, ya que las bandas 
    presentan mas de 2 valores posibles. Categorizar los valores observados
    en solamente dos categorias implicaria una perdida de informacion.

A) Realice un Análisis de Coordenadas Principales para encontrar la 
configuración de las variedades de pepino en función de esta caracterización
molecular. Encuentra asociaciones en función del tipo de pepino?

    En la Figura 1 podemos ver que los pepinos del tipo F suelen encontrarse en el 
    primer cuadrante, los del tipo P en el segundo cuadrdante, los de tipo A en el 
    tercero, y los de tipo H en el cuarto. Sin embargo esta ordenacion es imprecisa,
    ya que por ejemplo, hay pepinos de los tipo F y A en el segundo cuadrante. 
    Sino estuvieran los colores que indican los tipos de pepinos, probablemente 
    obtendriamos agrupamientos que estuvieran compuestos en su mayoria un unico 
    tipo de pepino, pero que tambien incluirian pepinos de otros tipos.

    ```{r}
    coordenadas_principales <- cmdscale(sqrt(matriz_distancia), eig = TRUE)
    
    datos_CP <- as.data.frame(coordenadas_principales$points)
    colnames(datos_CP) <- c("c1", "c2")
    datos_CP$etiqueta <- datos$Var
    datos_CP$variedad <- substr(datos_CP$etiqueta, 1, 1)
    ```
    
    ```{r}
    # Guardo coordenadas_principales
    saveRDS(
      coordenadas_principales, 
      here::here("doc", "tp1", "shared", "parte_5", "coordenadas_principales.rds")
    )
    ```
    
    ```{r, fig.cap="Caracterizacion molecular de las variedades de pepino."}
    ggplot(datos_CP) + 
      geom_point(aes(c1, c2, color = variedad), size = 4) + 
      geom_label_repel(aes(c1, c2, label = etiqueta), max.overlaps = 30) + 
      geom_vline(xintercept = 0, linetype = "dashed", color = "grey30", alpha = 0.5) + 
      geom_hline(yintercept = 0, linetype = "dashed", color = "grey30", alpha = 0.5) + 
      labs(
        x = "Coordenada 1",
        y = "Coordenada 2",
        color = "Tipo de fruto"
      )
    ```
    
A)  Encuentre el dendograma ultramétrico con ligamiento UPGMA

    ```{r}
    cluster_molecular <- hclust(matriz_distancia, method = "average")
    dendro_data <- dendro_data_k(cluster_molecular, k=4)
    ```
    
    ```{r}
    saveRDS(
      cluster_molecular, 
      here::here("doc", "tp1", "shared", "parte_5", "cluster_molecular.rds")
    )
    ```
    
    ```{r, fig.height=6.5, fig.width=6, fig.cap="Dendograma Ultrametrico con ligamiento UPGMA.", class.source = 'fold-hide'}
    ggplot(dendro_data$segments) + 
      geom_segment(
        aes(x = x, y = y, xend = xend, yend = yend, color = as.factor(clust)),
        size = 1.2,
        lineend = "round"
      ) + 
      geom_text(
        aes(x = x, y = y - 0.025, label = label, color = as.factor(clust)), 
        data = dendro_data$labels
      ) + 
      coord_flip() + 
      labs(
        y = "Distancia"
      ) + 
      scale_colour_manual(
        values = c("grey30", scales::hue_pal()(4))
      ) + 
      theme(
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(),
        axis.title.x = element_text(size = 14), 
        axis.title.y = element_blank(), 
        axis.text.x = element_text(size = 12),
        axis.text.y = element_blank(), 
        axis.line = element_blank(), 
        axis.ticks.y = element_blank(),
        plot.title = element_text(hjust = 0.5),
        legend.position = "none"
      )
    ```


A) Mida a través de su matriz cofenética la concordancia con la matriz de 
distancias que le dio origen

    ```{r}
    distancia_cofenetica_upgma <- cophenetic(cluster_molecular)
    concordancia <- cor(matriz_distancia, distancia_cofenetica_upgma)
    ```

    La concordancia entre la matriz de distancias cofenética y la matriz de 
    distancia original es igual  a `r round(concordancia, 3)`. En la Figura 3
    se puede ver la asociacion positiva entre las dos medidas de distancia. La
    dispersion en la nube de puntos aumenta a medida que la distancia es mayor,
    lo que significa que las dos medidas de distancia tienden a diferir mas 
    cuando la distancia entre los tipos de pepinos es mayor.

    ```{r, fig.cap="Grafico de dispersion entre distancia original y distancia cofenética a partir de d endograma Ultrametico con ligamiento UPGMA. La linea azul representa a la recta identidad."}
    concordancia_df <- data.frame(
        x = as.vector(distancia_cofenetica_upgma),
        y = as.vector(matriz_distancia)
    )
    ggplot(concordancia_df) + 
        geom_abline(slope = 1, intercept = 0, size=1.1, color = "#2980b9", alpha = 0.7) + 
        geom_point(aes(x, y), size = 3, alpha = 0.4) + 
        labs(
            x = "Distancia cofenética",
            y = "Distancia original"
        )
    ```
    

A) Halle el dendograma aditivo Neighbor Joining

    ```{r}
    rapds_nj <- nj(matriz_distancia)
    ggtree::ggtree(rapds_nj, ladderize = FALSE) + ggtree::geom_tiplab()
    ```
    
    ```{r}
    saveRDS(
      rapds_nj, 
      here::here("doc", "tp1", "shared", "parte_5", "rapds_nj.rds")
    )
    ```
    
A) Mida su concordancia con matriz de distancia original

    ```{r}
    distancia_cofenetica_nj <- as.dist(cophenetic(rapds_nj), diag = TRUE, upper = FALSE)
    concordancia <- cor(distancia_cofenetica_nj, matriz_distancia)
    ```
    
    La concordancia entre la matriz de distancias cofenética construida a partir
    del dendograma aditivo Neighbor Joining y la matriz de distancia original es
    igual  a `r round(concordancia, 3)`.**falta interpretar**
    
    ```{r, fig.cap="Grafico de dispersion entre distancia original y distancia cofenética a partir del dendograma aditivo. La linea azul representa a la recta identidad."}
    concordancia_df <- data.frame(
        x = as.vector(distancia_cofenetica_nj),
        y = as.vector(matriz_distancia)
    )
    ggplot(concordancia_df) + 
        geom_abline(slope = 1, intercept = 0, size=1.1, color = "#2980b9", alpha = 0.7) + 
        geom_point(aes(x, y), size = 3, alpha = 0.4) + 
        labs(
            x = "Distancia cofenética",
            y = "Distancia original"
        )
      
    ```


A) Relacione ambos dendogramas y saque conclusiones

    Falta sacar conclusiones.

    ```{r}
    concordancia <- cor(distancia_cofenetica_nj, distancia_cofenetica_upgma)
    ```
    
    La concordancia es `r round(concordancia, 3)`. **interpretar**
    
    


